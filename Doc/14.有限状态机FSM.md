# ğŸš€ æœ‰é™çŠ¶æ€æœº (FSM) ä½¿ç”¨æŒ‡å—

## ğŸŒŸ ç‰¹ç‚¹
- **æ¨¡å—åŒ–è®¾è®¡**ï¼šé€šè¿‡ `TriggerBehavior` å’Œ `ExecuteBehavior` å®ç°è§¦å‘å’Œæ‰§è¡Œçš„åˆ†ç¦»ã€‚
- **ä¼˜å…ˆçº§æ§åˆ¶**ï¼šæ”¯æŒè§¦å‘å™¨çš„ä¼˜å…ˆçº§æ’åºï¼Œç¡®ä¿çŠ¶æ€åˆ‡æ¢çš„é€»è¾‘æ€§ã€‚
- **çµæ´»æ‰©å±•**ï¼šæ”¯æŒåŠ¨æ€æ·»åŠ è§¦å‘å™¨å’Œæ‰§è¡Œé€»è¾‘ã€‚
- **æ‰‹åŠ¨ä¸è‡ªåŠ¨æ›´æ–°**ï¼šæ—¢æ”¯æŒè‡ªåŠ¨çŠ¶æ€æ›´æ–°ï¼Œä¹Ÿæ”¯æŒæ‰‹åŠ¨æŒ‡å®šçŠ¶æ€æ›´æ–°ã€‚

## ğŸ›  åŠŸèƒ½
1. **çŠ¶æ€è§¦å‘å™¨**ï¼šé€šè¿‡ `TriggerBehavior` å®šä¹‰çŠ¶æ€åˆ‡æ¢çš„æ¡ä»¶å’Œç›®æ ‡çŠ¶æ€ã€‚
2. **çŠ¶æ€æ‰§è¡Œå™¨**ï¼šé€šè¿‡ `ExecuteBehavior` å®šä¹‰æ¯ä¸ªçŠ¶æ€çš„æ‰§è¡Œé€»è¾‘ã€‚
3. **ä¼˜å…ˆçº§æ’åº**ï¼šè§¦å‘å™¨æŒ‰ä¼˜å…ˆçº§æ’åºï¼Œç¡®ä¿é«˜ä¼˜å…ˆçº§è§¦å‘å™¨ä¼˜å…ˆæ‰§è¡Œã€‚
4. **çŠ¶æ€é€ƒé€¸**ï¼šé€šè¿‡ `SetEscape` æ–¹æ³•å®šä¹‰ç‰¹æ®Šçš„çŠ¶æ€é€€å‡ºé€»è¾‘ã€‚
5. **çŠ¶æ€æœºæ§åˆ¶**ï¼šæ”¯æŒå¯åŠ¨ã€åœæ­¢ã€é‡å¯ç­‰æ“ä½œã€‚

## ğŸ“– ä½¿ç”¨æ–¹æ³•

é¦–å…ˆï¼Œä¸ºäº†ä¾¿äºç†è§£ï¼Œæˆ‘ä»¬å‡è®¾æœ‰ä¸€ä¸ªæ•°æ®æº `Role`ï¼Œå®ƒç»§æ‰¿ `ILinkStateOwner` ï¼ŒåŒ…å«äº†çŠ¶æ€æœºéœ€è¦çš„æ‰€æœ‰æ•°æ®ã€‚

`Role` ä¸Šå­˜åœ¨æ ‡è¯†çŠ¶æ€æœºå½“å‰çŠ¶æ€çš„ `StateIndex` å±æ€§ã€‚

`StateIndex` å­—æ®µçš„å€¼æ˜¯ä¸€ä¸ªæ•´æ•°ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªæšä¸¾ç±»å‹è½¬æ¢ä¸º **int**ï¼Œè¡¨ç¤ºå½“å‰çŠ¶æ€çš„ç´¢å¼•ã€‚
```csharp
public enum MyState
{
    Idle = 0,
    Run,
    Attack,
    Thinking,
    Dead,
    // å…¶ä»–çŠ¶æ€...
}

public class Role : Monobehaviour, ILinkStateOwner
{
   public int StateIndex { get; set; }
      // å…¶ä»–æ•°æ®...
   public float Speed;
   public Vector3 Direction;
   public Data Balabala;
}
```

### 1. åˆå§‹åŒ–çŠ¶æ€æœº
```csharp
Role role = RoleUtils.Get(); // æ•°æ®æºå®ä¾‹
var stateMachine = new LinkStateMachine<Role>(role, true);
```

### 2. è®¾ç½®åˆå§‹çŠ¶æ€
```csharp
stateMachine.SetEntry(EntryState); // è®¾ç½®åˆå§‹çŠ¶æ€

private int EntryState(Role data)
{
   if (data.Speed > 0)
   {
      return (int) State.Run;
   }
    // è¿”å›åˆå§‹çŠ¶æ€ç´¢å¼•
    // è¿”å›çš„çŠ¶æ€ç´¢å¼•ä¼šè¢«èµ‹å€¼ç»™ data.StateIndex
    return (int) State.idle;
}
```

### 3. æ·»åŠ çŠ¶æ€æ‰§è¡Œé€»è¾‘
```csharp
stateMachine.SetExecute((int) State.Run, OnRunExecute);

private void OnRunExecute(Role data, float deltaTime)
{
   // æ‰§è¡ŒçŠ¶æ€ å¥”è·‘ çš„é€»è¾‘
   data.transform.position += data.Direction * (data.Speed * deltaTime);
}
```

### 4. æ·»åŠ çŠ¶æ€è§¦å‘å™¨
```csharp
stateMachine.SetTrigger((int) State.Run, ConditionMet, TargetState, TriggerPriority.Preferred);

bool ConditionMet(Role data)
{
    // åˆ¤æ–­æ¡ä»¶æ˜¯å¦æ»¡è¶³
    return data.Speed == 0; // å‡è®¾é€Ÿåº¦ä¸º 0 æ—¶åˆ‡æ¢çŠ¶æ€
}

int TargetState(Role data)
{
   // è¿”å›ç›®æ ‡çŠ¶æ€ç´¢å¼•
   // è¿”å›çš„çŠ¶æ€ç´¢å¼•ä¼šè¢«èµ‹å€¼ç»™ data.StateIndex
   return (int) State.Idle; // å‡è®¾ç›®æ ‡çŠ¶æ€ä¸º Idle
}
```

psï¼š`LinkStateMachine<T>`æ”¯æŒé“¾å¼è°ƒç”¨ï¼Œæ‚¨å¯ä»¥åœ¨åŒä¸€è¡Œä»£ç ä¸­è®¾ç½®å¤šä¸ªè§¦å‘å™¨å’Œæ‰§è¡Œå™¨ã€‚

```csharp
stateMachine.SetTrigger(0, ConditionMet, TargetState, TriggerPriority.Preferred)
            .SetExecute(0, OnRunExecute)
            .SetTrigger(new []{2, 3, 4}, ConditionMet, TargetState)ï¼›
```

### 5. å¯åŠ¨çŠ¶æ€æœº
```csharp
stateMachine.Start();
```

### 6. æ›´æ–°çŠ¶æ€æœº
```csharp
stateMachine.Update(deltaTime);
```

### 7. æ‰‹åŠ¨æ›´æ–°çŠ¶æ€
```csharp
stateMachine.UpdateManually((int) State.Attack, deltaTime); // å¼ºåˆ¶æ›´æ–°åˆ°çŠ¶æ€ State.Attack
```

## âš  æ³¨æ„äº‹é¡¹
1. **çŠ¶æ€ç´¢å¼•å”¯ä¸€æ€§**ï¼šç¡®ä¿æ¯ä¸ªçŠ¶æ€çš„ç´¢å¼•å”¯ä¸€ï¼Œé¿å…å†²çªï¼Œæœ€å¥½ä½¿ç”¨æšä¸¾ç±»å‹ã€‚
2. **è§¦å‘å™¨ä¼˜å…ˆçº§**ï¼šä¼˜å…ˆçº§é«˜çš„è§¦å‘å™¨ä¼šä¼˜å…ˆæ‰§è¡Œï¼Œåˆç†è®¾ç½®ä¼˜å…ˆçº§ã€‚
3. **è§¦å‘å™¨æ¡ä»¶**ï¼šè§¦å‘å™¨æ¡ä»¶è¿”å› `true` æ—¶æ‰ä¼šè§¦å‘çŠ¶æ€åˆ‡æ¢ã€‚
4. **çŠ¶æ€æ‰§è¡Œé€»è¾‘**ï¼šç¡®ä¿æ¯ä¸ªçŠ¶æ€çš„æ‰§è¡Œé€»è¾‘ä¸ä¼šé˜»å¡ä¸»çº¿ç¨‹ã€‚
5. **çŠ¶æ€é€ƒé€¸**ï¼š`SetEscape` æ–¹æ³•ä¼šåœ¨è§¦å‘æ¡ä»¶æ»¡è¶³æ—¶åœæ­¢çŠ¶æ€æœºè¿è¡Œã€‚

## ğŸ¯ ç¤ºä¾‹ä»£ç 
ä»¥ä¸‹æ˜¯ä¸€ä¸ªå®Œæ•´çš„çŠ¶æ€æœºç¤ºä¾‹ï¼š
```csharp
public class Role : MonoBehaviour, ILinkStateOwner
{
   public MyState StateIndex { get; set; }
   public float Speed;
   public Vector3 Direction;
}

public class RoleStateMachine : MonoBehaviour
{
   private LinkStateMachine<Role> stateMachine;

   private void Start(Role role)
   {
      // åˆå§‹åŒ–çŠ¶æ€æœº
      stateMachine = new LinkStateMachine<Role>(role, true);

      // è®¾ç½®åˆå§‹çŠ¶æ€
      stateMachine.SetEntry(EntryState)
         .SetExecute((int)MyState.Run, OnRunExecute) // æ·»åŠ çŠ¶æ€æ‰§è¡Œé€»è¾‘
         .SetExecute((int)MyState.Idle, OnIdleExecute)
         .SetTrigger((int)MyState.Run, IsIdleCondition, ToIdleState) // æ·»åŠ çŠ¶æ€è§¦å‘å™¨
         .SetTrigger((int)MyState.Idle, IsRunCondition, ToRunState)
         .Start(); // å¯åŠ¨çŠ¶æ€æœº
   }

   private int EntryState(Role data)
   {
      var initState = data.Speed > 0 ? MyState.Run : MyState.Idle;
      return (int)initState;
   }

   private void OnRunExecute(Role data, float deltaTime)
   {
      data.transform.position += data.Direction * (data.Speed * deltaTime);
   }

   private void OnIdleExecute(Role data, float deltaTime)
   {
      // æ‰§è¡ŒçŠ¶æ€ Idle çš„é€»è¾‘
      Debug.Log("Idle state logic executed.");
   }

   private bool IsIdleCondition(Role data)
   {
      return RoleUtils.IsEnemyInRange(data); // å‡è®¾æ•Œäººè¿›å…¥èŒƒå›´
   }

   private int ToIdleState(Role data)
   {
      data.Speed = 0f; // è®¾ç½®é€Ÿåº¦ä¸º 0
      return (int)MyState.Idle;
   }

   private bool IsRunCondition(Role data)
   {
      // åˆ¤æ–­æ¡ä»¶æ˜¯å¦æ»¡è¶³
      return RoleUtils.IsEnemyOutofRange(data); // å‡è®¾æ•Œäººè¶…å‡ºèŒƒå›´
   }

   private int ToRunState(Role data)
   {
      data.Speed = 5f; // è®¾ç½®é€Ÿåº¦
      data.Direction = Vector3.someDirection; // è®¾ç½®æ–¹å‘
      return (int)MyState.Run;
   }

   private void Update()
   {
      // æ›´æ–°çŠ¶æ€æœº
      stateMachine.Update(Time.deltaTime);

      // æ‰‹åŠ¨æ›´æ–°çŠ¶æ€
      if (Input.GetKeyDown(KeyCode.Space))
      {
         stateMachine.UpdateManually((int)MyState.Attack, Time.deltaTime); // å¼ºåˆ¶æ›´æ–°åˆ°çŠ¶æ€ Attack
      }
   }
}
```

é€šè¿‡ä»¥ä¸Šä»£ç ï¼Œæ‚¨å¯ä»¥å¿«é€Ÿå®ç°ä¸€ä¸ªå®ç”¨çš„æœ‰é™çŠ¶æ€æœºã€‚
