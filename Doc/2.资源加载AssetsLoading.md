# 资源加载系统文档

## 系统特点

### 1. **只提供异步加载**
- 本框架的资源加载系统完全基于异步操作，旨在优化性能并避免阻塞主线程。
- 提供多种异步回调方式，满足不同场景需求，例如：
  - 以参数方式传入
  - YieldInstruction式异步加载
  - 事件注册

### 2. **基于接口开发**
- 资源加载系统采用接口驱动设计（`IAssetLoader`和`IAssetManager`），便于扩展和自定义。
- 可无缝接入其他资源管理工具（以接入 Unity Addressables、AssetBundle）。
- 开发者只需实现框架提供的资源加载接口，即可替换默认实现。

### 3.**离散化管理**
- 离散化的管理方式，让开发者可以专注于当前情景下的资源调度，避免全局卸载某个资源导致报错
- 资源加载通过实例化的

### 4.**资源异步加载 & 全路径为key**
- 框架内虽然提供了同步加载的方法，但为了接口统一和webGL平台上兼容性问题，所有接口方法内没有同步加载方法，只在资源加载实例内提供了同步加载方法。
- 同时`IAssetLoader`使用全路径作为资源加载的key。当然，如果是自己实现的`IAssetLoader`可以选择其他含义的string，只需要自行转换传入参数即可。
- 使用`IAssetLoader`加载时，值得注意的接口如下：
```csharp
namespace PowerCellStudio
{
    public interface IAssetLoader 
    {
        // 卸载实例内部缓存，并尝试计算Bundle引用计数
        public bool Release(string address);
        
        // 检查资源是否在加载
        public bool IsLoading(string address);
        
        // 将回调作为参数传入，进行异步加载
        public void LoadAsync<T>(string address, Action<T> onSuccess, Action onFail = null) where T : UnityEngine.Object;

        // 以Task的方式进行异步加载，不建议在WebGL中使用
        public Task<T> LoadTask<T>(string address) where T : UnityEngine.Object;

        // 以YieldInstruction的形式进行异步加载，也可用返回的LoaderYieldInstruction<T>注册加载完成事件
        public LoaderYieldInstruction<T> LoadAsYieldInstruction<T>(string address) where T : UnityEngine.Object;

        // 直接将预制体生成为GameObject放置在场景内，注意在Addressable模式下，onSuccess可能会在生成后的下一帧才执行
        public void AsyncLoadNInstantiate(string address, Action<GameObject> onSuccess, Action onFail = null);
        
        // 直接将预制体生成为GameObject并设置父节点内，注意在Addressable模式下，onSuccess可能会在生成后的下一帧才执行
        public void AsyncLoadNInstantiate(string address, Transform parent, Action<GameObject> onSuccess, Action onFail = null);
    }
}
```

---

## 使用示例

以下是资源加载系统的典型使用方式：

### 使用方法

#### 1.初始化资源加载系统
初始化已经集成再`SceneMainBase`内，如果有特殊情况需要自行初始化资源加载系统，以下为示例:
```csharp
    public abstract class SceneMainBase : MonoBehaviour
    {        
        protected virtual void Awake()
        {
            DontDestroyOnLoad(gameObject);
            AssetUtils.Init(this, OnAssetUtilsInited);
        }

        private void OnAssetUtilsInited()
        {
            AssetLog.Log("AddressableManager Inited!");
            
            // 资源系统初始化完成，可以进行资源加载
            // do something
            StartGameLogic();
        }
    }
```

### 离散化的管理方式
本资源管理使用了离散化的管理方式，开发者通过`AssetUtils.SpawnLoader()`获得一个`IAssetLoader`，通过`IAssetLoader`加载需要的资源，同时`IAssetLoader`会自动缓存加载的资源、计算bundle引用计数，在不需要`IAssetLoader`时，使用`AssetUtils`将`IAssetLoader.DeSpawnLoader()`回收`IAssetLoader`，并自动解除资源缓存和计算bundle引用计数。

值得注意的是，以上的资源缓存只局限于所归属的`IAssetLoader`的内部，即清除一个`IAssetLoader`的相同原始资源，不会造成其他`IAssetLoader`内相同原始资源的缓存失效。

因此`IAssetLoader`最适宜的使用方式是：将资源加载流程分割为数个小的情景（一个UI打开、一场战斗开始等），在情景开始时获取`IAssetLoader`，在这个情景结束时回收`IAssetLoader`。

以下为使用例子：

```csharp
public class ExampleBattleCase 
{
    private IAssetLoader _assetsLoader;

    // 在开始时获取一个IAssetLoader，并使用其加载资源
    public void Init()
    {
        _assetsLoader = AssetUtils.SpawnLoader(this.GetType().name);
        LoadMap();
        LoadHero();
        CoroutineRuner.StartCoroutine(CreateEnemyPool());
    }

    // 当情景销毁时，先清楚场景内的资源，回收IAssetLoader，将_assetsLoader置空防止回收的IAssetLoader被调用
    public void Deinit()
    {
        ClearEnemyPool();
        AssetUtils.DeSpawnLoader(_assetsLoader);
        _assetsLoader = null;
    }

    private void LoadMap()
    {
        // 将回调作为参数传入，进行异步加载
        _assetsLoader.LoadAsync<GameObject>("Assets/Res/exampleMapPath.prefab", OnMapLoaded);
    }

    private void OnMapLoaded(GameObject mapPrefab)
    {
        var map = GameObject.Instantiate(mapPrefab);
        Debug.log("map was Created!");
    }

    private void LoadHero()
    {
        // 用返回的LoaderYieldInstruction<T>注册加载完成事件
        var loadHandler = _assetsLoader.LoadAsYieldInstruction<GameObject>("Assets/Res/exampleHeroPath.prefab");
        loadHandler.onLoadSuccess += (prefab) =>
        {
            var hero = GameObject.Instantiate(prefab);
            Debug.log("Hero was Created!");
        }
    }

    private Stack<GameObject> _enemyPool;
    private GameObject _enemyPrefab;
    private IEnumertor CreateEnemyPool()
    {
        // 以YieldInstruction的形式进行异步加载
        var loadHandler = _assetsLoader.LoadAsYieldInstruction<GameObject>("Assets/Res/exampleEnemyPath.prefab");
        yield return loadHandler;
        var prefab = loadHandler.asset;
        if (!prefab) 
        {
            Debug.Error("Create Enemy Pool Failed!");
            yield break;
        }
        _enemyPrefab = prefab;
        _enemyPool = new Stack<GameObject>();
        for (var i = 0; i < 50; i++)
        {
            _enemyPool.Push(GameObject.Instantiate(prefab));
        }
        Debug.log("Enemy Pool was Created!");
    }

    private void ClearEnemyPool()
    {
        if(_enemyPool == null) return;
        _enemyPrefab = null;
        while(_enemyPool.Count > 0)
        {
            var item = _enemyPool.Pop();
            GameObject.Destroy(item);
        }
        _enemyPool = null;
    }
}
```
