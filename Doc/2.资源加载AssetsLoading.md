# 资源加载系统文档

## 🌟 系统特点

### 1.🚀 **只提供异步加载**
- 本框架的资源加载系统完全基于异步操作，旨在优化性能并避免阻塞主线程。
- 提供多种异步回调方式，满足不同场景需求，例如：
  - 以参数方式传入
  - YieldInstruction式异步加载
  - 事件注册

### 2.🔧 **基于接口开发**
- 资源加载系统采用接口驱动设计（`IAssetLoader`和`IAssetManager`），便于扩展和自定义。
- 可无缝接入其他资源管理工具（以接入 Unity Addressables、AssetBundle）。
- 开发者只需实现框架提供的资源加载接口，即可替换默认实现。

### 3.📦 **离散化管理**
- 离散化的管理方式，让开发者可以专注于当前情景下的资源调度，避免全局卸载某个资源导致报错。
- 资源加载通过实例化的`IAssetLoader`作为载体。

### 4.⚡ **资源异步加载 & 全路径为key**
- 框架内虽然提供了同步加载的方法，但为了接口统一和webGL平台上兼容性问题，所有接口方法内没有同步加载方法，只在`IAssetLoader`实例内提供了同步加载方法。
- 同时`IAssetLoader`使用全路径作为资源加载的key。当然，如果是自己实现的`IAssetLoader`可以选择其他含义的string，只需要自行转换传入参数即可。
- 使用`IAssetLoader`加载时，值得注意的接口如下：
```csharp
namespace PowerCellStudio
{
    public interface IAssetLoader 
    {
        // 卸载实例内部缓存，并尝试计算Bundle引用计数
        public bool Release(string address);
        
        // 检查资源是否在加载
        public bool IsLoading(string address);
        
        // 将回调作为参数传入，进行异步加载
        public void LoadAsync<T>(string address, Action<T> onSuccess, Action onFail = null) where T : UnityEngine.Object;

        // 以Task的方式进行异步加载，不建议在WebGL中使用
        public Task<T> LoadTask<T>(string address) where T : UnityEngine.Object;

        // 以YieldInstruction的形式进行异步加载，也可用返回的LoaderYieldInstruction<T>注册加载完成事件
        public LoaderYieldInstruction<T> LoadAsYieldInstruction<T>(string address) where T : UnityEngine.Object;

        // 直接将预制体生成为GameObject放置在场景内，注意在Addressable模式下，onSuccess可能会在生成后的下一帧才执行
        public void AsyncLoadNInstantiate(string address, Action<GameObject> onSuccess, Action onFail = null);
        
        // 直接将预制体生成为GameObject并设置父节点内，注意在Addressable模式下，onSuccess可能会在生成后的下一帧才执行
        public void AsyncLoadNInstantiate(string address, Transform parent, Action<GameObject> onSuccess, Action onFail = null);
    }
}
```

---

## 🛠️ 使用示例

### 1.✨ **初始化资源加载系统**
初始化已经集成再`SceneMainBase`内，如果有特殊情况需要自行初始化资源加载系统，以下为示例:
```csharp
    public abstract class SceneMainBase : MonoBehaviour
    {        
        protected virtual void Awake()
        {
            DontDestroyOnLoad(gameObject);
            AssetUtils.Init(this, OnAssetUtilsInited);
        }

        private void OnAssetUtilsInited()
        {
            AssetLog.Log("AddressableManager Inited!");
            
            // 资源系统初始化完成，可以进行资源加载
            // do something
            StartGameLogic();
        }
    }
```

### 2.📂 **离散化的管理方式**
本资源管理使用了离散化的管理方式，开发者通过`AssetUtils.SpawnLoader()`获得一个`IAssetLoader`。

通过`IAssetLoader`加载需要的资源，同时`IAssetLoader`会自动缓存加载的资源、计算bundle引用计数。

在不需要`IAssetLoader`时，使用`AssetUtils.DeSpawnLoader()`回收`IAssetLoader`，并自动解除资源缓存和计算bundle引用计数。

值得注意的是，以上的资源缓存只局限于所归属的`IAssetLoader`的内部，即清除一个`IAssetLoader`的资源，不会造成其他`IAssetLoader`内相同原始资源的缓存失效。

因此`IAssetLoader`最适宜的使用方式是：将资源加载流程分割为数个小的情景（打开一个UI、开始一场战斗等），在情景开始时获取`IAssetLoader`，在这个情景结束时回收`IAssetLoader`。

以下为使用例子：

```csharp
public class ExampleBattleCase 
{
    private IAssetLoader _assetsLoader;

    // 在开始时获取一个IAssetLoader，并使用其加载资源
    public void Init()
    {
        _assetsLoader = AssetUtils.SpawnLoader(this.GetType().name);
        LoadMap();
        LoadHero();
        CoroutineRuner.StartCoroutine(CreateEnemyPool());
    }

    // 当情景销毁时，先清除场景内的资源，回收IAssetLoader，将_assetsLoader置空防止回收的IAssetLoader被调用
    public void Deinit()
    {
        ClearEnemyPool();
        AssetUtils.DeSpawnLoader(_assetsLoader);
        _assetsLoader = null;
    }

    private void LoadMap()
    {
        // 将回调作为参数传入，进行异步加载
        _assetsLoader.LoadAsync<GameObject>("Assets/Res/exampleMapPath.prefab", OnMapLoaded);
    }

    private void OnMapLoaded(GameObject mapPrefab)
    {
        var map = GameObject.Instantiate(mapPrefab);
        Debug.log("map was Created!");
    }

    private void LoadHero()
    {
        // 用返回的LoaderYieldInstruction<T>注册加载完成事件
        var loadHandler = _assetsLoader.LoadAsYieldInstruction<GameObject>("Assets/Res/exampleHeroPath.prefab");
        loadHandler.onLoadSuccess += (prefab) =>
        {
            var hero = GameObject.Instantiate(prefab);
            Debug.log("Hero was Created!");
        }
    }

    private Stack<GameObject> _enemyPool;
    private GameObject _enemyPrefab;
    private IEnumertor CreateEnemyPool()
    {
        // 以YieldInstruction的形式进行异步加载
        var loadHandler = _assetsLoader.LoadAsYieldInstruction<GameObject>("Assets/Res/exampleEnemyPath.prefab");
        yield return loadHandler;
        var prefab = loadHandler.asset;
        if (!prefab) 
        {
            Debug.Error("Create Enemy Pool Failed!");
            yield break;
        }
        _enemyPrefab = prefab;
        _enemyPool = new Stack<GameObject>();
        for (var i = 0; i < 50; i++)
        {
            _enemyPool.Push(GameObject.Instantiate(prefab));
        }
        Debug.log("Enemy Pool was Created!");
    }

    private void ClearEnemyPool()
    {
        if(_enemyPool == null) return;
        _enemyPrefab = null;
        while(_enemyPool.Count > 0)
        {
            var item = _enemyPool.Pop();
            GameObject.Destroy(item);
        }
        _enemyPool = null;
    }
}
```

---

## 📖 框架内提供的情景
框架已经在UI系统、对象池系统、音频系统、配置表工具中，在适当时刻获取`IAssetLoader`实例，开发者一般不需要另外去获取。

### 1.🖼️ **UI系统中**
例如在UI系统中，UI会在打开时自动获取一个`IAssetLoader`:
```csharp
private IAssetLoader _assetsAssetLoader;
public IAssetLoader assetsAssetLoader => _assetsAssetLoader;

void IUIComponent.Open(object data)
{
    if(_assetsAssetLoader == null || !_assetsAssetLoader.spawned)
        _assetsAssetLoader = AssetUtils.SpawnLoader(this.GetType().Name);
    OnOpen(data);
}
```
开发者只需在要加载资源时调用`assetsAssetLoader`对应接口即可。

在UI销毁时，`assetsAssetLoader`会自动回收，无需做额外处理。
```csharp
public virtual void OnUIDestroy()
{
    AssetUtils.DeSpawnLoader(_assetsAssetLoader);
    _assetsAssetLoader = null;
}
```

### 2.🎵 **其他系统中**
在对象池系统、音频系统、配置表工具等情景，模块内功能会自行处理和`IAssetLoader`的交互，开发者无需直接调用`IAssetLoader`，因此不在此介绍。

---

## 🔄 接入其他加载工具
如果开发者选择使用其他资源管理工具，可以通过以下方式

### 1.🛠️ **实现IAssetManager**
首先实现一个继承`IAssetManager`接口的类（以`ExampleAssetManager`为例），这个类主要的作用是作为`IAssetLoader`的容器，用来生成、回收`IAssetLoader`。
以下为`IAssetManager`需要实现的接口：
```csharp
public interface IAssetManager
{
    // 获得资源管理器初始化状态，在初始化是会被调用
    AssetInitState initState {get;};

    // 获得资源管理器初始化状态，在初始化是会被调用
    float initProcess {get;};

    // 资源管理器初始化逻辑，传入的coroutineRunner作为开启协程的起点，callBack一般是初始化后游戏启动逻辑
    public void Init(MonoBehaviour coroutineRunner, Action callBack);
    
    // 获取IAssetLoader的接口，tag用以区分IAssetLoader被使用的场合
    public IAssetLoader SpawnLoader(string tag);
    
    // 回收IAssetLoader的接口，在此处理IAssetLoader.Deinit()，并且回收至对象池中
    public void DeSpawnLoader(IAssetLoader loader);
    
    // 回收所有IAssetLoader，这一步会卸载全部加载的资源
    public void DeSpawnAllLoader();
    
    // 回收具有特定tag的IAssetLoader
    public void DeSpawnLoaderByTag(string tag);

    // 加载场景
    public void LoadScene(string sceneName, Action onComplete, bool unLoadOtherScene = false);

    // 卸载场景
    public void UnloadScene(string name);
}
```

---

## ⚠️ 注意事项
1. **资源管理生命周期**
   - 确保在使用`IAssetLoader`时正确初始化和回收，避免资源泄漏。
2. **异步加载的回调处理**
   - 异步加载的回调可能会在下一帧执行，需注意逻辑顺序。
3. **全路径作为Key**
   - 使用全路径作为资源加载的Key，确保路径正确无误。