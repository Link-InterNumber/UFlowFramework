## 对象池功能

### **功能实现原理**

UFlow使用的对象池结构如下：

```plaintext

PoolManager
    |
    └── PoolGroup
            |
            ├── GameObjectPool (LinkPool<GameObject>) ─────── GameObject
            |
            └── PoolableObjectPool (LinkPool<IPoolable>) ─── PoolObject (IPoolable)

```

UFlow的对象池系统，最小单位是继承`IPoolable`接口的对象，或者`GameObject`。

`LinkPool<T>`对象则是`IPoolable`的容器，能容纳多个相同类型的`IPoolable`，用来实现对象池的生成、存放、回收、销毁等具体功能。

`PoolGroup`则是`LinkPool<T>`的容器，能容纳多个不同的`LinkPool<T>`，其目的是为场景区分不同对象池集合，内部可以同时容纳`GameObject`和`IPoolable`对象。

理论上，开发者可以不使用`PoolManager`，仅使用`PoolGroup`和`LinkPool<T>`就可以实现对象池功能。

---

### 操作示例

#### 1.**非GameObject**

##### 继承IPoolable接口

首先让需要对象池收容的对象继承`IPoolable`，下面以`ExamplePoolObj`为例：

```csharp

public class ExamplePoolObj : IPoolable
{
    public ExamplePoolObj()
    {
        _maybeData = new List<int>();
    }

    private List<int> _maybeData;

    public LinkPool<IPoolable> LinkPool { set; get; }
    
    // 以下为需要实现的方法

    // 对象从对象池取出时，会被调用
    public void OnSpawn()
    {
        _maybeData.Clear();
    }

    // 对象内部主动回收到对象池的方法
    public void DeSpawn()
    {
        LinkPool.Release(this);
    }

    // 对象被对象池回收时，会被调用
    public void OnDeSpawn()
    {
        for (var i = 0; i < _maybeData.Count; i ++)
        {
            Debug.Log(_maybeData[i]);
        }
    }

    // 对象超过对象池容纳上限时不会被回收，此时调用销毁方法
    public void Dispose()
    {
        _maybeData = null;
    }
}

```

##### 使用PoolGroup的对象池功能

完成以上后需要在PoolGroup注册ExamplePoolObj。

有两种在PoolGroup注册的方式.

在多个场景之间，通过`PoolManager`提供的方法注册，之后也是通过`PoolManager`获取、回收对象，不需要对象池时在`PoolManager`中注销对象池。

以下为示例：

```csharp

// 注册时，需要传入对象生成的方法、最大数量、初始化数量，最后的 groupName 枚举用来区别 PoolGroup 的使用场景。
var createFun = () => new ExamplePoolObj();
PoolableObjectPool pool = PoolManager.instance.Register<ExamplePoolObj>(createFun, maxNum: 50, initNum: 10, groupName: PoolGroupName.Default)

// 如果你的IPoolable类有不带参数的构造函数，可以使用 GetOrNew 方法，不用传入对象生成的方法，此时默认最大数量为10，初始化数量5。
ExamplePoolObj item = PoolManager.instance.GetOrNew<ExamplePoolObj>(groupName: PoolGroupName.Default)

// 获取pool后可以修改最大容量
PoolableObjectPool pool = PoolManager.instance.GetPool<ExamplePoolObj>(PoolGroupName.Default);
pool.SetMaxSize(100);

// 从池中获取对象
ExamplePoolObj item1 = PoolManager.instance.Get<ExamplePoolObj>(groupName: PoolGroupName.Default);

// 将对象回收至对象池
PoolManager.instance.Release(item, groupName: PoolGroupName.Default);
PoolManager.instance.Release(item1, groupName: PoolGroupName.Default);

// 注销对象池，对已经取出池的对象没有影响
PoolManager.instance.UnRegister<ExamplePoolObj>(PoolGroupName.Default);

```

另外就是通过直接创建PoolGroup来使用，这可以满足单个场景内有需要